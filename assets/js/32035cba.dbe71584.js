"use strict";(self.webpackChunkhyperfy_docs=self.webpackChunkhyperfy_docs||[]).push([[7780],{8051:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var i=t(4848),l=t(8453);const s={sidebar_label:"Guide: Destructibles",sidebar_position:85},a="Destructibles",o={id:"developers/destructibles",title:"Destructibles",description:"In this tutorial we will be showing you how to create a destructible barrel that tosses anyone caught in its blast radius into the air. We will use many powerful Hyperfy features including sync state, custom fields, file uploads, editor-only helpers, component references, signals, triggers, side effects that resolve over time, NFT ownership checks, and more.",source:"@site/docs/developers/destructibles.md",sourceDirName:"developers",slug:"/developers/destructibles",permalink:"/hyperfy-docs/docs/developers/destructibles",draft:!1,unlisted:!1,editUrl:"https://github.com/madjin/hyperfy-docs/tree/main/docs/developers/destructibles.md",tags:[],version:"current",lastUpdatedBy:"Knar",lastUpdatedAt:1711081194e3,sidebarPosition:85,frontMatter:{sidebar_label:"Guide: Destructibles",sidebar_position:85},sidebar:"developers",previous:{title:"Sync State",permalink:"/hyperfy-docs/docs/developers/sync-state"},next:{title:"Uploading",permalink:"/hyperfy-docs/docs/developers/uploading"}},r={},c=[{value:"App Design",id:"app-design",level:2},{value:"Model",id:"model",level:2},{value:"Sync state",id:"sync-state",level:2},{value:"Editor fields",id:"editor-fields",level:2},{value:"Handle user file uploads",id:"handle-user-file-uploads",level:2},{value:"Signals",id:"signals",level:2},{value:"Light",id:"light",level:2},{value:"GIFs",id:"gifs",level:2},{value:"Sound",id:"sound",level:2},{value:"Physics",id:"physics",level:2},{value:"Blockchain",id:"blockchain",level:2},{value:"Final code",id:"final-code",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"destructibles",children:"Destructibles"}),"\n",(0,i.jsx)(n.p,{children:"In this tutorial we will be showing you how to create a destructible barrel that tosses anyone caught in its blast radius into the air. We will use many powerful Hyperfy features including sync state, custom fields, file uploads, editor-only helpers, component references, signals, triggers, side effects that resolve over time, NFT ownership checks, and more."}),"\n",(0,i.jsxs)(n.p,{children:["All of the media used in this project can be found in the ",(0,i.jsx)(n.code,{children:"destructibles"})," app in the ",(0,i.jsx)(n.a,{href:"https://github.com/hyperfy-io/hyperfy-recipes",children:"Hyperfy-recipes"})," repository. Take a moment to download the files in the ",(0,i.jsx)(n.code,{children:"/assets"})," folder and add them to your project to avoid reference errors when we use them later."]}),"\n",(0,i.jsxs)(n.p,{children:["This advanced tutorial expects you to have an understanding of the Hyperfy SDK and Javascript/React code patterns. We won't explain everything in detail so please see the relevant API documentation pages for more information, and feel free to join our ",(0,i.jsx)(n.a,{href:"https://discord.gg/TGtyTEWB2X",children:"Discord"})," and ask questions!"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"#final-code",children:"Skip to final code"})}),"\n",(0,i.jsx)(n.h2,{id:"app-design",children:"App Design"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"While active, only a red barrel is visible"}),"\n",(0,i.jsxs)(n.li,{children:["When the barrel is clicked:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The barrel disappears"}),"\n",(0,i.jsx)(n.li,{children:"A sound effect plays"}),"\n",(0,i.jsx)(n.li,{children:"A light flashes briefly then fades away over time (light can be disabled)"}),"\n",(0,i.jsx)(n.li,{children:"GIFs appear briefly then disappear"}),"\n",(0,i.jsxs)(n.li,{children:["any user inside a trigger square is shot into the air","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If the user owns at least 1 nft of a specific contract they are protected from this effect (can be disabled)"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["When the user is in the editor menu, the following changes will happen until the editor is closed:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The light turns on"}),"\n",(0,i.jsx)(n.li,{children:"The gifs appear and loop"}),"\n",(0,i.jsxs)(n.li,{children:["A transparent box appears which scales with the blast radius","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"trigger is not visible if the barrel has been exploded, to make it clear it's not active and to tweak visuals"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"All variables exposed as editor fields"}),"\n",(0,i.jsx)(n.li,{children:"Barrel state synchronized across network"}),"\n",(0,i.jsx)(n.li,{children:"Expose triggers to interact with external apps"}),"\n",(0,i.jsx)(n.li,{children:"Expose signals so other apps can interact with ours, and the app can be controlled in the editor menu"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"model",children:"Model"}),"\n",(0,i.jsxs)(n.p,{children:["Start by adding a barrel model with a kinematic rigid body so it interacts with the physics engine. Make sure you have a GLB model in your app's ",(0,i.jsx)(n.code,{children:"/assets"})," folder with the name ",(0,i.jsx)(n.code,{children:"barrel.glb"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React from "react";\n\nexport default function Destructible() {\n  return (\n    <app>\n      //highlight-start\n      <rigidbody type="kinematic">\n        <model src="barrel.glb" collision="trimesh" />\n      </rigidbody>\n      //highlight-end\n    </app>\n  );\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"sync-state",children:"Sync state"}),"\n",(0,i.jsx)(n.p,{children:"Our app will have two states, active and inactive. By default the app will be active, and when clicked the barrel will be destroyed and will no longer be active."}),"\n",(0,i.jsx)(n.p,{children:"To synchronize this state across multiplayer we import the useSyncState hook from the hyperfy library. This hook is very similar to useState: you tell it which variable to bind to and it returns the networked state variable and a dispatch function to send updates to other players. The dispatch actions are defined in the actions section of a getStore function you export (very similar to Redux if you're familiar)."}),"\n",(0,i.jsxs)(n.p,{children:["Import ",(0,i.jsx)(n.code,{children:"useSyncState"})," and use it to create the synchronized state object. Outside of our app's default function add the getStore function with a ",(0,i.jsx)(n.code,{children:"Destroy(state)"})," action (NOTE: the capital D is just to differentiate the two, don't mix them up)."]}),"\n",(0,i.jsxs)(n.p,{children:["To make the app interactive we add an ",(0,i.jsx)(n.code,{children:"onPointerDown"})," event to the model. This event fires when a user is in range of the model and clicks. We pass it a callback function ",(0,i.jsx)(n.code,{children:"destroy()"}),", which calls the ",(0,i.jsx)(n.code,{children:"dispatch()"})," function, sending the ",(0,i.jsx)(n.code,{children:"Destroy"})," action across the network. When any client receives the ",(0,i.jsx)(n.code,{children:"Destroy"})," action, the corresponding ",(0,i.jsx)(n.code,{children:"Destroy"})," function is executed, setting the state variable ",(0,i.jsx)(n.code,{children:"active"})," to false. We will use this ",(0,i.jsx)(n.code,{children:"active"})," variable later on."]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Click to view code"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React from "react";\n//highlight-next-line\nimport { useSyncState } from "hyperfy";\n\nexport default function Destructible() {\n  //highlight-next-line\n  const [active, dispatch] = useSyncState((state) => state.active);\n\n  //highlight-start\n  function destroy() {\n    dispatch("Destroy");\n  }\n  //highlight-end\n\n  return (\n    <app>\n      <rigidbody type="kinematic">\n        <model\n          src="barrel.glb"\n          collision="trimesh"\n          //highlight-next-line\n          onPointerDown={destroy}\n        />\n      </rigidbody>\n    </app>\n  );\n}\n\n//highlight-start\nexport function getStore(state = { active: true }) {\n  return {\n    state,\n    actions: {\n      Destroy(state) {\n        state.active = false;\n      },\n    },\n  };\n}\n//highlight-end\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"editor-fields",children:"Editor fields"}),"\n",(0,i.jsx)(n.p,{children:"The barrel currently has no text hint when you hover over it. We can easily add some hard-coded text to this component, but it's usually a good idea to expose these variables to the editor (at least during development). This lets you tweak your variables from within the hyperfy editor, giving consumers of your app a more customizable experience."}),"\n",(0,i.jsxs)(n.p,{children:["First we import ",(0,i.jsx)(n.code,{children:"useFields"})," from the hyperfy library and call it inside our app function. We use object destructuring syntax on the result to get our ",(0,i.jsx)(n.code,{children:"label"})," variable, which will be tied to a field in the editor UI. We add the ",(0,i.jsx)(n.code,{children:"onPointerDownHint"})," prop to our model and give it the ",(0,i.jsx)(n.code,{children:"label"})," value for the pointer hint."]}),"\n",(0,i.jsxs)(n.p,{children:["A new ",(0,i.jsx)(n.code,{children:"fields"})," property must be added to the object returned from the ",(0,i.jsx)(n.code,{children:"getStore"})," function which contains an array of all the editor fields we want to expose to the user. When destructuring the ",(0,i.jsx)(n.code,{children:"useFields"})," result, the variable names must match a key in the fields array. Now you can change the hover label of the model through the editor!"]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Click to view code"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React from "react";\nimport {\n  useSyncState,\n  //highlight-next-line\n  useFields,\n} from "hyperfy";\n\nexport default function Destructible() {\n  const [active, dispatch] = useSyncState((state) => state.active);\n  //highlight-next-line\n  const { label } = useFields();\n\n  function destroy() {\n    dispatch("Destroy");\n  }\n\n  return (\n    <app>\n      <rigidbody type="kinematic">\n        <model\n          src="barrel.glb"\n          collision="trimesh"\n          onPointerDown={destroy}\n          //highlight-next-line\n          onPointerDownHint={label}\n        />\n      </rigidbody>\n    </app>\n  );\n}\n\nexport function getStore(state = { active: true }) {\n  return {\n    state,\n    actions: {\n      Destroy(state) {\n        state.active = false;\n      },\n    },\n    //highlight-start\n    fields: [\n      { type: "text", key: "label", label: "Hover label", initial: "Explode" },\n    ],\n    //highlight-end\n  };\n}\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"handle-user-file-uploads",children:"Handle user file uploads"}),"\n",(0,i.jsxs)(n.p,{children:["We can make our barrel model customizable with an editor field as well but we need a new hook to handle the file uploads. The ",(0,i.jsx)(n.code,{children:"useFile"})," hook takes a file uploaded from an editor field and returns a cloud URL of the asset."]}),"\n",(0,i.jsxs)(n.p,{children:["Import ",(0,i.jsx)(n.code,{children:"useFile"})," from hyperfy, add the ",(0,i.jsx)(n.code,{children:"model"})," property to the ",(0,i.jsx)(n.code,{children:"useFields"})," destructure, add a ",(0,i.jsx)(n.code,{children:"file"})," field to the fields array (and a ",(0,i.jsx)(n.code,{children:"category"})," for files as well), pass the ",(0,i.jsx)(n.code,{children:"model"})," to the ",(0,i.jsx)(n.code,{children:"useFile"})," hook, and swap out the src prop in the model component. the ",(0,i.jsx)(n.code,{children:"??"})," syntax will default to our barrel model (this would throw an error without it)."]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Click to view code"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React from "react";\nimport {\n  useSyncState,\n  useFields,\n  //highlight-next-line\n  useFile,\n} from "hyperfy";\n\nexport default function Destructible() {\n  const [active, dispatch] = useSyncState((state) => state.active);\n  const {\n    label,\n    //highlight-next-line\n    model,\n  } = useFields();\n  //highlight-next-line\n  const modelUrl = useFile(model);\n\n  function destroy() {\n    dispatch("Destroy");\n  }\n\n  return (\n    <app>\n      <rigidbody type="kinematic">\n        <model\n          //highlight-next-line\n          src={modelUrl ?? "barrel.glb"}\n          collision="trimesh"\n          onPointerDown={destroy}\n          onPointerDownHint={label}\n        />\n      </rigidbody>\n    </app>\n  );\n}\n\nexport function getStore(state = { active: true }) {\n  return {\n    state,\n    actions: {\n      Destroy(state) {\n        state.active = false;\n      },\n    },\n    fields: [\n      { type: "text", key: "label", label: "Hover label", initial: "Explode" },\n      //highlight-start\n      {\n        type: "section",\n        label: "Files",\n      },\n      { type: "file", key: "model", label: "Model", accept: ".glb" },\n      //highlight-end\n    ],\n  };\n}\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"signals",children:"Signals"}),"\n",(0,i.jsxs)(n.p,{children:["If we want other apps to be able to set the state of our custom app we need to add signals. This also allows us to control the app's state from within the editor UI. Import ",(0,i.jsx)(n.code,{children:"useSignal"})," from hyperfy, then call it by passing in the name of our signal ",(0,i.jsx)(n.code,{children:"Destroy"})," as well as a callback function, which in our case is ",(0,i.jsx)(n.code,{children:"destroy"}),". When the ",(0,i.jsx)(n.code,{children:"Destroy"})," signal is received, our app will execute the same exact code as it would if you had clicked on the model."]}),"\n",(0,i.jsxs)(n.p,{children:["While we're in there let's add a ",(0,i.jsx)(n.code,{children:"Reset"})," signal, a corresponding ",(0,i.jsx)(n.code,{children:"reset"})," function, and a sync state action that sets ",(0,i.jsx)(n.code,{children:"active"})," to true."]}),"\n",(0,i.jsxs)(n.p,{children:["The basic state is setup now so let's add some conditional rendering. Check the ",(0,i.jsx)(n.code,{children:"active"})," variable before rendering the ",(0,i.jsx)(n.code,{children:"rigidbody"})," component. The model will now only appear when the state is active. Try clicking on the model as well as playing with the Destroy and Reset buttons in the editor to see the model appear and disappear."]}),"\n",(0,i.jsxs)(n.p,{children:["We'll also quickly add some triggers for Destroy and Reset, which other apps can listen for and react. Import ",(0,i.jsx)(n.code,{children:"useWorld"})," from hyperfy and call it to get a reference to the world object. We add the trigger editor fields and can trigger them using ",(0,i.jsx)(n.code,{children:"world.trigger()"})," but we will do that later."]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Click to view code"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React from "react";\nimport {\n  useSyncState,\n  //highlight-next-line\n  useWorld,\n  useFields,\n  useFile,\n  //highlight-next-line\n  useSignal,\n} from "hyperfy";\n\nexport default function Destructible() {\n  const [active, dispatch] = useSyncState((state) => state.active);\n  const { label, model } = useFields();\n  const modelUrl = useFile(model);\n  //highlight-next-line\n  const world = useWorld();\n  //highlight-start\n  useSignal("Reset", reset);\n  useSignal("Destroy", destroy);\n  //highlight-end\n\n  //highlight-start\n  function reset() {\n    dispatch("Reset");\n  }\n  //highlight-end\n\n  function destroy() {\n    dispatch("Destroy");\n  }\n\n  return (\n    <app>\n      //highlight-start\n      {active && (\n        <>\n          //highlight-end\n          <rigidbody type="kinematic">\n            <model\n              src={modelUrl ?? "barrel.glb"}\n              collision="trimesh"\n              onPointerDown={destroy}\n              onPointerDownHint={label}\n            />\n          </rigidbody>\n          //highlight-start\n        </>\n      )}\n      //highlight-end\n    </app>\n  );\n}\n\nexport function getStore(state = { active: true }) {\n  return {\n    state,\n    actions: {\n      Destroy(state) {\n        state.active = false;\n      },\n      //highlight-start\n      Reset(state) {\n        state.active = true;\n      },\n      //highlight-end\n    },\n    fields: [\n      { type: "text", key: "label", label: "Hover label", initial: "Explode" },\n      {\n        type: "section",\n        label: "Files",\n      },\n      { type: "file", key: "model", label: "Model", accept: ".glb" },\n      //highlight-start\n      {\n        type: "section",\n        label: "Triggers",\n      },\n      {\n        type: "trigger",\n        name: "Destroy",\n      },\n      {\n        type: "trigger",\n        name: "Reset",\n      },\n      //highlight-end\n    ],\n  };\n}\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"light",children:"Light"}),"\n",(0,i.jsxs)(n.p,{children:["This is where it gets a bit more complex. We are going to add a light component and have it react to the sync state variable. When the state of ",(0,i.jsx)(n.code,{children:"active"})," changes, if the state is ",(0,i.jsx)(n.code,{children:"false"})," we will briefly flash the light and have it fade out over a specified duration. If the state is ",(0,i.jsx)(n.code,{children:"true"})," we will reset everything."]}),"\n",(0,i.jsxs)(n.p,{children:["Add an ",(0,i.jsx)(n.code,{children:"arealight"})," component plus some editor fields to control the properties of the light including position, intensity, and color. Conditionally render the component based on an enablelight editor field, which allows the user to disable the dynamic light. Also, we need to add a ",(0,i.jsx)(n.code,{children:"giflifetime"})," editor field which will be used to clean up the light side effect."]}),"\n",(0,i.jsxs)(n.p,{children:["To adjust the intensity of our light we need to import ",(0,i.jsx)(n.code,{children:"useState"})," from react and create an ",(0,i.jsx)(n.code,{children:"intensity"})," state variable which we can set using ",(0,i.jsx)(n.code,{children:"setIntensity"}),". We also need a reference to our ",(0,i.jsx)(n.code,{children:"light"})," component, so we import ",(0,i.jsx)(n.code,{children:"useRef"})," from react and create a ",(0,i.jsx)(n.code,{children:"lightRef"})," which we pass into the ",(0,i.jsx)(n.code,{children:"ref"})," prop of our light."]}),"\n",(0,i.jsxs)(n.p,{children:["Because we are dealing with side-effects we need to use ",(0,i.jsx)(n.code,{children:"useEffect"})," from react. We will us the ",(0,i.jsx)(n.code,{children:"active"})," variable as our effect's dependency. In order to avoid glitches on the server, we need to check if the code is running on the client or the server. In our effect, we first check if the code is running on the client by checking ",(0,i.jsx)(n.code,{children:"!world.isServer"}),". If the app state is NOT active (meaning it has been destroyed), use ",(0,i.jsx)(n.code,{children:"setIntensity"})," to turn the light on (if it's enabled in the editor field). If our state is active, we reset the light intensity back to 0."]}),"\n",(0,i.jsxs)(n.p,{children:["Next, we create a ",(0,i.jsx)(n.code,{children:"world.onUpdate"})," function, which will be fired every frame and give us a ",(0,i.jsx)(n.code,{children:"delta"})," variable representing the amount of time in seconds since the last frame. We assign this to a variable ",(0,i.jsx)(n.code,{children:"cleanup"})," which will be called later, to unsubscribe from the event. Inside the ",(0,i.jsx)(n.code,{children:"onUpdate"})," function we add up the delta time to our total time elapsed, and if the elapsed time is greater than our ",(0,i.jsx)(n.code,{children:"lightlifetime"})," we set the intensity of the light to 0 and set fading=false to prevent further loops before cleanup. If not enough time has elapsed, we do a linear fade between our maximum intensity and 0, and set the intensity to that value."]}),"\n",(0,i.jsxs)(n.p,{children:["The onUpdate function would run forever like this unless we unsubscribe to it. This is why we use setTimeout to cleanup this function. After a specified duration, the cleanup function is called and the opacity is set to 0. The duration is called ",(0,i.jsx)(n.code,{children:"giflifetime"})," because we will also be cleaning up the gif effect in here later. This might be a messy way to do this in React but it works well enough."]}),"\n",(0,i.jsxs)(n.p,{children:["We also added in the ",(0,i.jsx)(n.code,{children:"world.trigger()"})," calls in the appropriate places now, because this section wasn't big enough.."]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Click to view code"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React, {\n  //highlight-next-line\n  seState,\n  //highlight-next-line\n  useEffect,\n  //highlight-next-line\n  useRef,\n} from "react";\nimport { useSyncState, useWorld, useFields, useFile, useSignal } from "hyperfy";\n\nexport default function Destructible() {\n  //highlight-next-line\n  const [intensity, setIntensity] = useState(0);\n  const [active, dispatch] = useSyncState((state) => state.active);\n  const {\n    label,\n    //highlight-next-line\n    lightcolor,\n    //highlight-next-line\n    lightintensity,\n    //highlight-next-line\n    lightscale,\n    //highlight-next-line\n    lightposition,\n    //highlight-next-line\n    lightlifetime,\n    //highlight-next-line\n    enablelight,\n    //highlight-next-line\n    giflifetime,\n    model,\n  } = useFields();\n  const modelUrl = useFile(model);\n  //highlight-next-line\n  const lightRef = useRef();\n  const world = useWorld();\n  useSignal("Reset", reset);\n  useSignal("Destroy", destroy);\n\n  function reset() {\n    dispatch("Reset");\n  }\n\n  function destroy() {\n    dispatch("Destroy");\n  }\n\n  //highlight-start\n  useEffect(() => {\n    if (!world.isServer) {\n      if (!active) {\n        world.trigger("Destroy");\n        setIntensity(lightintensity);\n\n        let timeElapsed = 0;\n        let fading = true;\n        const cleanup = world.onUpdate((delta) => {\n          if (fading) {\n            timeElapsed += delta * 1000;\n            if (timeElapsed >= lightlifetime) {\n              setIntensity(0);\n              fading = false;\n            } else {\n              const intensity =\n                (1 - timeElapsed / lightlifetime) * lightintensity;\n              setIntensity(intensity);\n            }\n          }\n        });\n\n        setTimeout(() => {\n          cleanup();\n          setIntensity(0);\n        }, giflifetime);\n      } else {\n        world.trigger("Reset");\n        setIntensity(0);\n      }\n    }\n  }, [active]);\n  //highlight-end\n\n  return (\n    <app>\n      {active && (\n        <>\n          <rigidbody type="kinematic">\n            <model\n              src={modelUrl ?? "barrel.glb"}\n              collision="trimesh"\n              onPointerDown={destroy}\n              onPointerDownHint={label}\n            />\n          </rigidbody>\n        </>\n      )}\n      //highlight-start\n      {enablelight && (\n        <arealight\n          ref={lightRef}\n          color={lightcolor}\n          position={[0, lightposition, 0]}\n          intensity={intensity}\n          depth={lightscale}\n          width={lightscale}\n        />\n      )}\n      //highlight-end\n    </app>\n  );\n}\n\nexport function getStore(state = { active: true }) {\n  return {\n    state,\n    actions: {\n      Destroy(state) {\n        state.active = false;\n      },\n      Reset(state) {\n        state.active = true;\n      },\n    },\n    fields: [\n      { type: "text", key: "label", label: "Hover label", initial: "Explode" },\n\n      //highlight-start\n      {\n        type: "section",\n        label: "Light",\n      },\n      {\n        type: "switch",\n        key: "enablelight",\n        label: "Enable Light",\n        options: [\n          { label: "true", value: true },\n          { label: "false", value: false },\n        ],\n        initial: true,\n      },\n      {\n        type: "text",\n        key: "lightcolor",\n        label: "Light Color",\n        initial: "orange",\n      },\n      {\n        type: "float",\n        key: "lightintensity",\n        label: "Light Intensity",\n        initial: 1000,\n      },\n      {\n        type: "float",\n        key: "lightscale",\n        label: "Light Scale",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightposition",\n        label: "Light Position",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightlifetime",\n        label: "Light Lifetime",\n        initial: 1000,\n      },\n      {\n        type: "section",\n        label: "GIFs",\n      },\n      {\n        type: "float",\n        key: "giflifetime",\n        label: "Gif Lifetime",\n        initial: 4000,\n      },\n      //highlight-end\n      {\n        type: "section",\n        label: "Files",\n      },\n      { type: "file", key: "model", label: "Model", accept: ".glb" },\n      {\n        type: "section",\n        label: "Triggers",\n      },\n      {\n        type: "trigger",\n        name: "Destroy",\n      },\n      {\n        type: "trigger",\n        name: "Reset",\n      },\n    ],\n  };\n}\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"gifs",children:"GIFs"}),"\n",(0,i.jsx)(n.p,{children:"Next to add some more visuals to the effect. When the barrel is destroyed, we will briefly show an animated gif and have it play for a few seconds before disappearing."}),"\n",(0,i.jsxs)(n.p,{children:["We use the ",(0,i.jsx)(n.code,{children:"useState"})," hook to create an ",(0,i.jsx)(n.code,{children:"opacity"})," state object, add new editor fields to upload the gifs and control position/scale, set up file hooks for the uploads, and add the new image components (this is all stuff we've done already). One image will be inside a ",(0,i.jsx)(n.code,{children:"billboard"})," component, which will always face towards the camera but locked to the vertical (y) axis. The other image will be flat on the ground with a fixed rotation. To set the angle of the GIF on the ground we import ",(0,i.jsx)(n.code,{children:"DEG2RAD"})," from hyperfy and multiply it by our degrees to get our rotation in radians."]}),"\n",(0,i.jsxs)(n.p,{children:["Inside our useEffect callback we set opacity to 1 when ",(0,i.jsx)(n.code,{children:"active"})," is false, and set it back to 0 at the end of the ",(0,i.jsx)(n.code,{children:"giflifetime"})," and if ",(0,i.jsx)(n.code,{children:"active"})," is true."]}),"\n",(0,i.jsxs)(n.p,{children:["Finally make sure you have the .gif files in your ",(0,i.jsx)(n.code,{children:"assets"})," folder named ",(0,i.jsx)(n.code,{children:"explosion-ground.gif"})," and ",(0,i.jsx)(n.code,{children:"explosion.gif"}),"."]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Click to view code"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React, { useState, useEffect, useRef } from "react";\nimport {\n  useSyncState,\n  useWorld,\n  useFields,\n  useFile,\n  //highlight-next-line\n  DEG2RAD,\n  useSignal,\n} from "hyperfy";\n\nexport default function Destructible() {\n  //highlight-next-line\n  const [opacity, setOpacity] = useState(0);\n  const [intensity, setIntensity] = useState(0);\n  const [active, dispatch] = useSyncState((state) => state.active);\n  const {\n    label,\n    lightcolor,\n    lightintensity,\n    lightscale,\n    lightposition,\n    lightlifetime,\n    enablelight,\n    giflifetime,\n    //highlight-next-line\n    gifscale,\n    model,\n    //highlight-next-line\n    gif,\n    //highlight-next-line\n    floorgif,\n    //highlight-next-line\n    gifposition,\n  } = useFields();\n  const modelUrl = useFile(model);\n  //highlight-next-line\n  const gifUrl = useFile(gif);\n  //highlight-next-line\n  const floorgifUrl = useFile(floorgif);\n  const lightRef = useRef();\n  const world = useWorld();\n  useSignal("Reset", reset);\n  useSignal("Destroy", destroy);\n\n  function reset() {\n    dispatch("Reset");\n  }\n\n  function destroy() {\n    dispatch("Destroy");\n  }\n\n  useEffect(() => {\n    if (!world.isServer) {\n      if (!active) {\n        world.trigger("Destroy");\n        //highlight-next-line\n        setOpacity(1);\n        setIntensity(lightintensity);\n\n        let timeElapsed = 0;\n        let fading = true;\n        const cleanup = world.onUpdate((delta) => {\n          if (fading) {\n            timeElapsed += delta * 1000;\n            if (timeElapsed >= lightlifetime) {\n              setIntensity(0);\n              fading = false;\n            } else {\n              const intensity =\n                (1 - timeElapsed / lightlifetime) * lightintensity;\n              setIntensity(intensity);\n            }\n          }\n        });\n\n        setTimeout(() => {\n          cleanup();\n          setIntensity(0);\n          //highlight-next-line\n          setOpacity(0);\n        }, giflifetime);\n      } else {\n        world.trigger("Reset");\n        setIntensity(0);\n        //highlight-next-line\n        setOpacity(0);\n      }\n    }\n  }, [active]);\n\n  return (\n    <app>\n      {active && (\n        <>\n          <rigidbody type="kinematic">\n            <model\n              src={modelUrl ?? "barrel.glb"}\n              collision="trimesh"\n              onPointerDown={destroy}\n              onPointerDownHint={label}\n            />\n          </rigidbody>\n        </>\n      )}\n      //highlight-start\n      <billboard axis="y">\n        <image\n          src={gifUrl ?? "explosion.gif"}\n          scale={gifscale}\n          position={[0, gifposition, 0]}\n          opacity={opacity}\n        />\n      </billboard>\n      <image\n        src={floorgifUrl ?? "explosion-ground.gif"}\n        position={[0, 0.05, 0]}\n        rotation={[-90 * DEG2RAD, 0, 0]}\n        scale={gifscale}\n        opacity={opacity}\n      />\n      //highlight-end\n      {enablelight && (\n        <arealight\n          ref={lightRef}\n          color={lightcolor}\n          position={[0, lightposition, 0]}\n          intensity={intensity}\n          depth={lightscale}\n          width={lightscale}\n        />\n      )}\n    </app>\n  );\n}\n\nexport function getStore(state = { active: true }) {\n  return {\n    state,\n    actions: {\n      Destroy(state) {\n        state.active = false;\n      },\n      Reset(state) {\n        state.active = true;\n      },\n    },\n    fields: [\n      { type: "text", key: "label", label: "Hover label", initial: "Explode" },\n      {\n        type: "section",\n        label: "Light",\n      },\n      {\n        type: "switch",\n        key: "enablelight",\n        label: "Enable Light",\n        options: [\n          { label: "true", value: true },\n          { label: "false", value: false },\n        ],\n        initial: true,\n      },\n      {\n        type: "text",\n        key: "lightcolor",\n        label: "Light Color",\n        initial: "orange",\n      },\n      {\n        type: "float",\n        key: "lightintensity",\n        label: "Light Intensity",\n        initial: 1000,\n      },\n      {\n        type: "float",\n        key: "lightscale",\n        label: "Light Scale",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightposition",\n        label: "Light Position",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightlifetime",\n        label: "Light Lifetime",\n        initial: 1000,\n      },\n      {\n        type: "section",\n        label: "GIFs",\n      },\n      {\n        type: "float",\n        key: "giflifetime",\n        label: "Gif Lifetime",\n        initial: 4000,\n      },\n      //highlight-start\n      { type: "float", key: "gifscale", label: "Gif Scale", initial: 4 },\n      {\n        type: "float",\n        key: "gifposition",\n        label: "Gif Y Position",\n        initial: 2,\n      },\n      //highlight-end\n      {\n        type: "section",\n        label: "Files",\n      },\n      //highlight-start\n      { type: "file", key: "gif", label: "Air Gif", accept: ".gif" },\n      { type: "file", key: "floorgif", label: "Floor Gif", accept: ".gif" },\n      //highlight-end\n      { type: "file", key: "model", label: "Model", accept: ".glb" },\n      {\n        type: "section",\n        label: "Triggers",\n      },\n      {\n        type: "trigger",\n        name: "Destroy",\n      },\n      {\n        type: "trigger",\n        name: "Reset",\n      },\n    ],\n  };\n}\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"sound",children:"Sound"}),"\n",(0,i.jsxs)(n.p,{children:["Adding the sound effect is pretty straightfoward now. Add the file editor field, useFile, useRef, and add the audio component and set the ref. Inside our useEffect function we can get the ",(0,i.jsx)(n.code,{children:"ref.current"})," and use that to play the audio with ",(0,i.jsx)(n.code,{children:"play()"}),". We don't have to worry about cleaning this up because we set the audio component to not loop. Make sure you have the .mp3 file in your ",(0,i.jsx)(n.code,{children:"assets"})," folder named ",(0,i.jsx)(n.code,{children:"explosion.mp3"}),"."]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Click to view code"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React, { useState, useEffect, useRef } from "react";\nimport {\n  useSyncState,\n  useWorld,\n  useFields,\n  useFile,\n  DEG2RAD,\n  useSignal,\n} from "hyperfy";\n\nexport default function Destructible() {\n  const [opacity, setOpacity] = useState(0);\n  const [intensity, setIntensity] = useState(0);\n  const [active, dispatch] = useSyncState((state) => state.active);\n  const {\n    label,\n    lightcolor,\n    lightintensity,\n    lightscale,\n    lightposition,\n    lightlifetime,\n    enablelight,\n    giflifetime,\n    gifscale,\n    model,\n    //highlight-next-line\n    sound,\n    gif,\n    floorgif,\n    gifposition,\n  } = useFields();\n  const modelUrl = useFile(model);\n  //highlight-next-line\n  const soundUrl = useFile(sound);\n  const gifUrl = useFile(gif);\n  const floorgifUrl = useFile(floorgif);\n  //highlight-next-line\n  const audioRef = useRef();\n  const lightRef = useRef();\n  const world = useWorld();\n  useSignal("Reset", reset);\n  useSignal("Destroy", destroy);\n\n  function reset() {\n    dispatch("Reset");\n  }\n\n  function destroy() {\n    dispatch("Destroy");\n  }\n\n  useEffect(() => {\n    if (!world.isServer) {\n      if (!active) {\n        world.trigger("Destroy");\n        //highlight-next-line\n        audioRef.current.play();\n        setOpacity(1);\n        setIntensity(lightintensity);\n\n        let timeElapsed = 0;\n        let fading = true;\n        const cleanup = world.onUpdate((delta) => {\n          if (fading) {\n            timeElapsed += delta * 1000;\n            if (timeElapsed >= lightlifetime) {\n              setIntensity(0);\n              fading = false;\n            } else {\n              const intensity =\n                (1 - timeElapsed / lightlifetime) * lightintensity;\n              setIntensity(intensity);\n            }\n          }\n        });\n\n        setTimeout(() => {\n          cleanup();\n          setIntensity(0);\n          setOpacity(0);\n        }, giflifetime);\n      } else {\n        world.trigger("Reset");\n        setIntensity(0);\n        setOpacity(0);\n      }\n    }\n  }, [active]);\n\n  return (\n    <app>\n      {active && (\n        <>\n          <rigidbody type="kinematic">\n            <model\n              src={modelUrl ?? "barrel.glb"}\n              collision="trimesh"\n              onPointerDown={destroy}\n              onPointerDownHint={label}\n            />\n          </rigidbody>\n        </>\n      )}\n      <billboard axis="y">\n        <image\n          src={gifUrl ?? "explosion.gif"}\n          scale={gifscale}\n          position={[0, gifposition, 0]}\n          opacity={opacity}\n        />\n      </billboard>\n      <image\n        src={floorgifUrl ?? "explosion-ground.gif"}\n        position={[0, 0.05, 0]}\n        rotation={[-90 * DEG2RAD, 0, 0]}\n        scale={gifscale}\n        opacity={opacity}\n      />\n      //highlight-start\n      <audio\n        src={soundUrl ?? "explosion.mp3"}\n        loop={false}\n        autoplay={false}\n        ref={audioRef}\n      />\n      //highlight-end\n      {enablelight && (\n        <arealight\n          ref={lightRef}\n          color={lightcolor}\n          position={[0, lightposition, 0]}\n          intensity={intensity}\n          depth={lightscale}\n          width={lightscale}\n        />\n      )}\n    </app>\n  );\n}\n\nexport function getStore(state = { active: true }) {\n  return {\n    state,\n    actions: {\n      Destroy(state) {\n        state.active = false;\n      },\n      Reset(state) {\n        state.active = true;\n      },\n    },\n    fields: [\n      { type: "text", key: "label", label: "Hover label", initial: "Explode" },\n\n      {\n        type: "section",\n        label: "Light",\n      },\n      {\n        type: "switch",\n        key: "enablelight",\n        label: "Enable Light",\n        options: [\n          { label: "true", value: true },\n          { label: "false", value: false },\n        ],\n        initial: true,\n      },\n      {\n        type: "text",\n        key: "lightcolor",\n        label: "Light Color",\n        initial: "orange",\n      },\n      {\n        type: "float",\n        key: "lightintensity",\n        label: "Light Intensity",\n        initial: 1000,\n      },\n      {\n        type: "float",\n        key: "lightscale",\n        label: "Light Scale",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightposition",\n        label: "Light Position",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightlifetime",\n        label: "Light Lifetime",\n        initial: 1000,\n      },\n      {\n        type: "section",\n        label: "GIFs",\n      },\n      {\n        type: "float",\n        key: "giflifetime",\n        label: "Gif Lifetime",\n        initial: 4000,\n      },\n      { type: "float", key: "gifscale", label: "Gif Scale", initial: 4 },\n      {\n        type: "float",\n        key: "gifposition",\n        label: "Gif Y Position",\n        initial: 2,\n      },\n      {\n        type: "section",\n        label: "Files",\n      },\n      { type: "file", key: "gif", label: "Air Gif", accept: ".gif" },\n      { type: "file", key: "floorgif", label: "Floor Gif", accept: ".gif" },\n      { type: "file", key: "model", label: "Model", accept: ".glb" },\n      //highlight-next-line\n      { type: "file", key: "sound", label: "Sound", accept: ".mp3" },\n      {\n        type: "section",\n        label: "Triggers",\n      },\n      {\n        type: "trigger",\n        name: "Destroy",\n      },\n      {\n        type: "trigger",\n        name: "Reset",\n      },\n    ],\n  };\n}\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"physics",children:"Physics"}),"\n",(0,i.jsx)(n.p,{children:"When the barrel is destroyed, we should have some kind of impact on the user. Let's throw them into the air! A trigger component can be used to keep track of who is inside the blast radius of the barrel."}),"\n",(0,i.jsxs)(n.p,{children:["We will import ",(0,i.jsx)(n.code,{children:"useEditing"})," and call it to create the ",(0,i.jsx)(n.code,{children:"editing"})," variable. This tells us if the user has the editor open which we will use to show the user a cube which represents the blast radius. Create a new state variable called inRange, which we use to keep track of whether the local player is in range of the trigger box. We need to add two new editor fields, blastradius which will determine the size of the trigger box, and upwardforce which will be the force applied to any user inside the trigger upon destruction."]}),"\n",(0,i.jsxs)(n.p,{children:["Create two callback functions, one for a user entering the trigger box and one for a user leaving the trigger box. When other users enter the box we want to ignore them (we can only apply physics force on the local avatar), so check if the user that entered/exited the box has the same user ID as the local client, and if so set the ",(0,i.jsx)(n.code,{children:"inRange"})," state accordingly. Now in the useEffect, we can check if the user is inRange, and if so we use ",(0,i.jsx)(n.code,{children:"world.applyUpwareForce()"})," to send them flying into the sky."]}),"\n",(0,i.jsxs)(n.p,{children:["We conditionally render a sem-transparent red box with the same size as the ",(0,i.jsx)(n.code,{children:"blastradius"})," editor variable, which acts as a scale guide for the trigger. Boxes and triggers have the same scale so a box is a useful stand-in to visualize the position and scale of a trigger. This box only shows up when the app state is active and the editor is open. Add the trigger component and hook it up to the callback functions we defined earlier."]}),"\n",(0,i.jsx)(n.p,{children:"Finally, we can add some extra utility to the editor window by conditionally setting props of the light and images when the editor is open. This lets us tweak the light and image properties without having to reset the app constantly."}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Click to view code"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React, { useState, useEffect, useRef } from "react";\nimport {\n  useSyncState,\n  useWorld,\n  useFields,\n  useFile,\n  //highlight-next-line\n  useEditing,\n  DEG2RAD,\n  useSignal,\n} from "hyperfy";\n\nexport default function Destructible() {\n  const [opacity, setOpacity] = useState(0);\n  //highlight-next-line\n  const [inRange, setInRange] = useState(false);\n  const [intensity, setIntensity] = useState(0);\n  const [active, dispatch] = useSyncState((state) => state.active);\n  const {\n    label,\n    lightcolor,\n    lightintensity,\n    lightscale,\n    lightposition,\n    lightlifetime,\n    enablelight,\n    //highlight-next-line\n    blastradius,\n    //highlight-next-line\n    upwardforce,\n    giflifetime,\n    gifscale,\n    model,\n    sound,\n    gif,\n    floorgif,\n    gifposition,\n  } = useFields();\n  const modelUrl = useFile(model);\n  const soundUrl = useFile(sound);\n  const gifUrl = useFile(gif);\n  const floorgifUrl = useFile(floorgif);\n  const audioRef = useRef();\n  const lightRef = useRef();\n  const world = useWorld();\n  //highlight-next-line\n  const editing = useEditing();\n  useSignal("Reset", reset);\n  useSignal("Destroy", destroy);\n\n  function reset() {\n    dispatch("Reset");\n  }\n\n  function destroy() {\n    dispatch("Destroy");\n  }\n\n  //highlight-start\n  function enterRange(e) {\n    const localUid = world.getAvatar();\n    if (localUid.uid == e) {\n      setInRange(true);\n    }\n  }\n  //highlight-end\n\n  //highlight-start\n  function leaveRange(e) {\n    const localUid = world.getAvatar();\n    if (localUid.uid == e) {\n      setInRange(false);\n    }\n  }\n  //highlight-end\n\n  useEffect(() => {\n    if (!world.isServer) {\n      if (!active) {\n        world.trigger("Destroy");\n        audioRef.current.play();\n        setOpacity(1);\n        setIntensity(lightintensity);\n\n        //highlight-next-line\n        if (inRange) {\n          //highlight-next-line\n          world.applyUpwardForce(upwardforce);\n          //highlight-next-line\n        }\n\n        let timeElapsed = 0;\n        let fading = true;\n        const cleanup = world.onUpdate((delta) => {\n          if (fading) {\n            timeElapsed += delta * 1000;\n            if (timeElapsed >= lightlifetime) {\n              setIntensity(0);\n              fading = false;\n            } else {\n              const intensity =\n                (1 - timeElapsed / lightlifetime) * lightintensity;\n              setIntensity(intensity);\n            }\n          }\n        });\n\n        setTimeout(() => {\n          cleanup();\n          setIntensity(0);\n          setOpacity(0);\n        }, giflifetime);\n      } else {\n        world.trigger("Reset");\n        setIntensity(0);\n        setOpacity(0);\n      }\n    }\n  }, [active]);\n\n  return (\n    <app>\n      {active && (\n        <>\n          //highlight-next-line\n          {editing && <box size={blastradius} opacity={0.15} color="red" />}\n          <rigidbody type="kinematic">\n            <model\n              src={modelUrl ?? "barrel.glb"}\n              collision="trimesh"\n              onPointerDown={destroy}\n              onPointerDownHint={label}\n            />\n          </rigidbody>\n        </>\n      )}\n      //highlight-next-line\n      <trigger size={blastradius} onEnter={enterRange} onLeave={leaveRange} />\n      <billboard axis="y">\n        <image\n          src={gifUrl ?? "explosion.gif"}\n          scale={gifscale}\n          position={[0, gifposition, 0]}\n          //highlight-next-line\n          opacity={editing ? 1 : opacity}\n        />\n      </billboard>\n      <image\n        src={floorgifUrl ?? "explosion-ground.gif"}\n        position={[0, 0.05, 0]}\n        rotation={[-90 * DEG2RAD, 0, 0]}\n        scale={gifscale}\n        //highlight-next-line\n        opacity={editing ? 1 : opacity}\n      />\n      <audio\n        src={soundUrl ?? "explosion.mp3"}\n        loop={false}\n        autoplay={false}\n        ref={audioRef}\n      />\n      {enablelight && (\n        <arealight\n          ref={lightRef}\n          color={lightcolor}\n          position={[0, lightposition, 0]}\n          //highlight-next-line\n          intensity={editing ? lightintensity : intensity}\n          depth={lightscale}\n          width={lightscale}\n        />\n      )}\n    </app>\n  );\n}\n\nexport function getStore(state = { active: true }) {\n  return {\n    state,\n    actions: {\n      Destroy(state) {\n        state.active = false;\n      },\n      Reset(state) {\n        state.active = true;\n      },\n    },\n    fields: [\n      { type: "text", key: "label", label: "Hover label", initial: "Explode" },\n      {\n        type: "section",\n        label: "Light",\n      },\n      {\n        type: "switch",\n        key: "enablelight",\n        label: "Enable Light",\n        options: [\n          { label: "true", value: true },\n          { label: "false", value: false },\n        ],\n        initial: true,\n      },\n      {\n        type: "text",\n        key: "lightcolor",\n        label: "Light Color",\n        initial: "orange",\n      },\n      {\n        type: "float",\n        key: "lightintensity",\n        label: "Light Intensity",\n        initial: 1000,\n      },\n      {\n        type: "float",\n        key: "lightscale",\n        label: "Light Scale",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightposition",\n        label: "Light Position",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightlifetime",\n        label: "Light Lifetime",\n        initial: 1000,\n      },\n      //highlight-start\n      {\n        type: "section",\n        label: "Explosion",\n      },\n      { type: "float", key: "blastradius", label: "Blast Radius", initial: 3 },\n      { type: "float", key: "upwardforce", label: "Upward Force", initial: 20 },\n      //highlight-end\n      {\n        type: "section",\n        label: "GIFs",\n      },\n      {\n        type: "float",\n        key: "giflifetime",\n        label: "Gif Lifetime",\n        initial: 4000,\n      },\n      { type: "float", key: "gifscale", label: "Gif Scale", initial: 4 },\n      {\n        type: "float",\n        key: "gifposition",\n        label: "Gif Y Position",\n        initial: 2,\n      },\n      {\n        type: "section",\n        label: "Files",\n      },\n      { type: "file", key: "gif", label: "Air Gif", accept: ".gif" },\n      { type: "file", key: "floorgif", label: "Floor Gif", accept: ".gif" },\n      { type: "file", key: "model", label: "Model", accept: ".glb" },\n      { type: "file", key: "sound", label: "Sound", accept: ".mp3" },\n      {\n        type: "section",\n        label: "Triggers",\n      },\n      {\n        type: "trigger",\n        name: "Destroy",\n      },\n      {\n        type: "trigger",\n        name: "Reset",\n      },\n    ],\n  };\n}\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"blockchain",children:"Blockchain"}),"\n",(0,i.jsx)(n.p,{children:"The last thing we'll add is NFT armor! This will protect anyone holding a balance of at least 1 of a specified NFT contract. Holders will not be knocked up in the air by the explosion (with an option to disable armor)."}),"\n",(0,i.jsxs)(n.p,{children:["We import the ",(0,i.jsx)(n.code,{children:"useEth"})," hook from hyperfy, create a new state variable ",(0,i.jsx)(n.code,{children:"balance"})," to hold a user's balance, hook up a couple new editor fields for the contract and the toggle to disable armor, and call ",(0,i.jsx)(n.code,{children:"useEth()"})," to get an instance of ",(0,i.jsx)(n.code,{children:"eth"}),". By passing in no chain into ",(0,i.jsx)(n.code,{children:"useEth()"})," we get an Ethereum instance."]}),"\n",(0,i.jsxs)(n.p,{children:["We cannot call an async function inside useEffect, but we can define an async function inside the effect and call that. We create a ",(0,i.jsx)(n.code,{children:"getBalance()"})," async function inside our effect, which we call whenever the component is initialized or reset. Now we can use the ",(0,i.jsx)(n.code,{children:"balance"})," and conditionally apply the upward force based on it (or ignore balance if the option is set)"]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Click to view code"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React, { useState, useEffect, useRef } from "react";\nimport {\n  useSyncState,\n  useWorld,\n  useFields,\n  useFile,\n  useEditing,\n  DEG2RAD,\n  useSignal,\n  //highlight-next-line\n  useEth,\n} from "hyperfy";\n\nexport default function Destructible() {\n  const [opacity, setOpacity] = useState(0);\n  const [inRange, setInRange] = useState(false);\n  //highlight-next-line\n  const [balance, setBalance] = useState(0);\n  const [intensity, setIntensity] = useState(0);\n  const [active, dispatch] = useSyncState((state) => state.active);\n  const {\n    label,\n    lightcolor,\n    lightintensity,\n    lightscale,\n    lightposition,\n    lightlifetime,\n    enablelight,\n    //highlight-next-line\n    nftarmor,\n    //highlight-next-line\n    nftarmorcontract,\n    blastradius,\n    upwardforce,\n    giflifetime,\n    gifscale,\n    model,\n    sound,\n    gif,\n    floorgif,\n    gifposition,\n  } = useFields();\n  const modelUrl = useFile(model);\n  const soundUrl = useFile(sound);\n  const gifUrl = useFile(gif);\n  const floorgifUrl = useFile(floorgif);\n  const audioRef = useRef();\n  const lightRef = useRef();\n  const world = useWorld();\n  const editing = useEditing();\n  //highlight-next-line\n  const eth = useEth();\n  useSignal("Reset", reset);\n  useSignal("Destroy", destroy);\n\n  function reset() {\n    dispatch("Reset");\n  }\n\n  function destroy() {\n    dispatch("Destroy");\n  }\n\n  function enterRange(e) {\n    const localUid = world.getAvatar();\n    if (localUid.uid == e) {\n      setInRange(true);\n    }\n  }\n\n  function leaveRange(e) {\n    const localUid = world.getAvatar();\n    if (localUid.uid == e) {\n      setInRange(false);\n    }\n  }\n\n  useEffect(() => {\n    //highlight-start\n    const getBalance = async () => {\n      const chain = await eth.getChain();\n      const address = world.getAvatar()?.address;\n      if (chain && address) {\n        const contract = eth.contract(nftarmorcontract);\n        const worlds = await contract.read("balanceOf", address);\n        setBalance(worlds);\n      } else {\n        setBalance(0);\n      }\n    };\n    //highlight-end\n\n    if (!world.isServer) {\n      if (!active) {\n        world.trigger("Destroy");\n        audioRef.current.play();\n        setOpacity(1);\n        setIntensity(lightintensity);\n\n        //highlight-next-line\n        if (inRange && (balance < 1 || !nftarmor)) {\n          world.applyUpwardForce(upwardforce);\n        }\n\n        let timeElapsed = 0;\n        let fading = true;\n        const cleanup = world.onUpdate((delta) => {\n          if (fading) {\n            timeElapsed += delta * 1000;\n            if (timeElapsed >= lightlifetime) {\n              setIntensity(0);\n              fading = false;\n            } else {\n              const intensity =\n                (1 - timeElapsed / lightlifetime) * lightintensity;\n              setIntensity(intensity);\n            }\n          }\n        });\n\n        setTimeout(() => {\n          cleanup();\n          setIntensity(0);\n          setOpacity(0);\n        }, giflifetime);\n      } else {\n        //highlight-next-line\n        getBalance();\n        world.trigger("Reset");\n        setIntensity(0);\n        setOpacity(0);\n      }\n    }\n  }, [active]);\n\n  return (\n    <app>\n      {active && (\n        <>\n          {editing && <box size={blastradius} opacity={0.15} color="red" />}\n          <rigidbody type="kinematic">\n            <model\n              src={modelUrl ?? "barrel.glb"}\n              collision="trimesh"\n              onPointerDown={destroy}\n              onPointerDownHint={label}\n            />\n          </rigidbody>\n        </>\n      )}\n      <trigger size={blastradius} onEnter={enterRange} onLeave={leaveRange} />\n      <billboard axis="y">\n        <image\n          src={gifUrl ?? "explosion.gif"}\n          scale={gifscale}\n          position={[0, gifposition, 0]}\n          opacity={editing ? 1 : opacity}\n        />\n      </billboard>\n      <image\n        src={floorgifUrl ?? "explosion-ground.gif"}\n        position={[0, 0.05, 0]}\n        rotation={[-90 * DEG2RAD, 0, 0]}\n        scale={gifscale}\n        opacity={editing ? 1 : opacity}\n      />\n      <audio\n        src={soundUrl ?? "explosion.mp3"}\n        loop={false}\n        autoplay={false}\n        ref={audioRef}\n      />\n      {enablelight && (\n        <arealight\n          ref={lightRef}\n          color={lightcolor}\n          position={[0, lightposition, 0]}\n          intensity={editing ? lightintensity : intensity}\n          depth={lightscale}\n          width={lightscale}\n        />\n      )}\n    </app>\n  );\n}\n\nexport function getStore(state = { active: true }) {\n  return {\n    state,\n    actions: {\n      Destroy(state) {\n        state.active = false;\n      },\n      Reset(state) {\n        state.active = true;\n      },\n    },\n    fields: [\n      { type: "text", key: "label", label: "Hover label", initial: "Explode" },\n      {\n        type: "section",\n        label: "Light",\n      },\n      {\n        type: "switch",\n        key: "enablelight",\n        label: "Enable Light",\n        options: [\n          { label: "true", value: true },\n          { label: "false", value: false },\n        ],\n        initial: true,\n      },\n      {\n        type: "text",\n        key: "lightcolor",\n        label: "Light Color",\n        initial: "orange",\n      },\n      {\n        type: "float",\n        key: "lightintensity",\n        label: "Light Intensity",\n        initial: 1000,\n      },\n      {\n        type: "float",\n        key: "lightscale",\n        label: "Light Scale",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightposition",\n        label: "Light Position",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightlifetime",\n        label: "Light Lifetime",\n        initial: 1000,\n      },\n      {\n        type: "section",\n        label: "Explosion",\n      },\n      //highlight-start\n      {\n        type: "switch",\n        key: "nftarmor",\n        label: "NFT Armor",\n        options: [\n          { label: "true", value: true },\n          { label: "false", value: false },\n        ],\n        initial: true,\n      },\n      {\n        type: "text",\n        key: "nftarmorcontract",\n        label: "NFT Armor Contract",\n        initial: "0xf53b18570db14c1e7dbc7dc74538c48d042f1332",\n      },\n      //highlight-end\n      { type: "float", key: "blastradius", label: "Blast Radius", initial: 3 },\n      { type: "float", key: "upwardforce", label: "Upward Force", initial: 20 },\n      {\n        type: "section",\n        label: "GIFs",\n      },\n      {\n        type: "float",\n        key: "giflifetime",\n        label: "Gif Lifetime",\n        initial: 4000,\n      },\n      { type: "float", key: "gifscale", label: "Gif Scale", initial: 4 },\n      {\n        type: "float",\n        key: "gifposition",\n        label: "Gif Y Position",\n        initial: 2,\n      },\n      {\n        type: "section",\n        label: "Files",\n      },\n      { type: "file", key: "gif", label: "Air Gif", accept: ".gif" },\n      { type: "file", key: "floorgif", label: "Floor Gif", accept: ".gif" },\n      { type: "file", key: "model", label: "Model", accept: ".glb" },\n      { type: "file", key: "sound", label: "Sound", accept: ".mp3" },\n      {\n        type: "section",\n        label: "Triggers",\n      },\n      {\n        type: "trigger",\n        name: "Destroy",\n      },\n      {\n        type: "trigger",\n        name: "Reset",\n      },\n    ],\n  };\n}\n'})})]}),"\n",(0,i.jsx)(n.p,{children:"And that's it! Feel free to remix this app and share the stuff you come up with!"}),"\n",(0,i.jsx)(n.h2,{id:"final-code",children:"Final code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React, { useState, useEffect, useRef } from "react";\nimport {\n  useSyncState,\n  useWorld,\n  useFields,\n  useFile,\n  useEditing,\n  DEG2RAD,\n  useSignal,\n  useEth,\n} from "hyperfy";\n\nexport default function Destructible() {\n  const [opacity, setOpacity] = useState(0);\n  const [inRange, setInRange] = useState(false);\n  const [balance, setBalance] = useState(0);\n  const [intensity, setIntensity] = useState(0);\n  const [active, dispatch] = useSyncState((state) => state.active);\n  const {\n    label,\n    lightcolor,\n    lightintensity,\n    lightscale,\n    lightposition,\n    lightlifetime,\n    enablelight,\n    nftarmor,\n    nftarmorcontract,\n    blastradius,\n    upwardforce,\n    giflifetime,\n    gifscale,\n    model,\n    sound,\n    gif,\n    floorgif,\n    gifposition,\n  } = useFields();\n  const modelUrl = useFile(model);\n  const soundUrl = useFile(sound);\n  const gifUrl = useFile(gif);\n  const floorgifUrl = useFile(floorgif);\n  const audioRef = useRef();\n  const lightRef = useRef();\n  const world = useWorld();\n  const editing = useEditing();\n  const eth = useEth();\n  useSignal("Reset", reset);\n  useSignal("Destroy", destroy);\n\n  function reset() {\n    dispatch("Reset");\n  }\n\n  function destroy() {\n    dispatch("Destroy");\n  }\n\n  function enterRange(e) {\n    const localUid = world.getAvatar();\n    if (localUid.uid == e) {\n      setInRange(true);\n    }\n  }\n\n  function leaveRange(e) {\n    const localUid = world.getAvatar();\n    if (localUid.uid == e) {\n      setInRange(false);\n    }\n  }\n\n  useEffect(() => {\n    const getBalance = async () => {\n      const chain = await eth.getChain();\n      const address = world.getAvatar()?.address;\n      if (chain && address) {\n        const contract = eth.contract(nftarmorcontract);\n        const worlds = await contract.read("balanceOf", address);\n        setBalance(worlds);\n      } else {\n        setBalance(0);\n      }\n    };\n\n    if (!world.isServer) {\n      if (!active) {\n        world.trigger("Destroy");\n        audioRef.current.play();\n        setOpacity(1);\n        setIntensity(lightintensity);\n\n        if (inRange && (balance < 1 || !nftarmor)) {\n          world.applyUpwardForce(upwardforce);\n        }\n\n        let timeElapsed = 0;\n        let fading = true;\n        const cleanup = world.onUpdate((delta) => {\n          if (fading) {\n            timeElapsed += delta * 1000;\n            if (timeElapsed >= lightlifetime) {\n              setIntensity(0);\n              fading = false;\n            } else {\n              const intensity =\n                (1 - timeElapsed / lightlifetime) * lightintensity;\n              setIntensity(intensity);\n            }\n          }\n        });\n\n        setTimeout(() => {\n          cleanup();\n          setIntensity(0);\n          setOpacity(0);\n        }, giflifetime);\n      } else {\n        getBalance();\n        world.trigger("Reset");\n        setIntensity(0);\n        setOpacity(0);\n      }\n    }\n  }, [active]);\n\n  return (\n    <app>\n      {active && (\n        <>\n          {editing && <box size={blastradius} opacity={0.15} color="red" />}\n          <rigidbody type="kinematic">\n            <model\n              src={modelUrl ?? "barrel.glb"}\n              collision="trimesh"\n              onPointerDown={destroy}\n              onPointerDownHint={label}\n            />\n          </rigidbody>\n        </>\n      )}\n      <trigger size={blastradius} onEnter={enterRange} onLeave={leaveRange} />\n      <billboard axis="y">\n        <image\n          src={gifUrl ?? "explosion.gif"}\n          scale={gifscale}\n          position={[0, gifposition, 0]}\n          opacity={editing ? 1 : opacity}\n        />\n      </billboard>\n      <image\n        src={floorgifUrl ?? "explosion-ground.gif"}\n        position={[0, 0.05, 0]}\n        rotation={[-90 * DEG2RAD, 0, 0]}\n        scale={gifscale}\n        opacity={editing ? 1 : opacity}\n      />\n      <audio\n        src={soundUrl ?? "explosion.mp3"}\n        loop={false}\n        autoplay={false}\n        ref={audioRef}\n      />\n      {enablelight && (\n        <arealight\n          ref={lightRef}\n          color={lightcolor}\n          position={[0, lightposition, 0]}\n          intensity={editing ? lightintensity : intensity}\n          depth={lightscale}\n          width={lightscale}\n        />\n      )}\n    </app>\n  );\n}\n\nexport function getStore(state = { active: true }) {\n  return {\n    state,\n    actions: {\n      Destroy(state) {\n        state.active = false;\n      },\n      Reset(state) {\n        state.active = true;\n      },\n    },\n    fields: [\n      { type: "text", key: "label", label: "Hover label", initial: "Explode" },\n      {\n        type: "section",\n        label: "Light",\n      },\n      {\n        type: "switch",\n        key: "enablelight",\n        label: "Enable Light",\n        options: [\n          { label: "true", value: true },\n          { label: "false", value: false },\n        ],\n        initial: true,\n      },\n      {\n        type: "text",\n        key: "lightcolor",\n        label: "Light Color",\n        initial: "orange",\n      },\n      {\n        type: "float",\n        key: "lightintensity",\n        label: "Light Intensity",\n        initial: 1000,\n      },\n      {\n        type: "float",\n        key: "lightscale",\n        label: "Light Scale",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightposition",\n        label: "Light Position",\n        initial: 10,\n      },\n      {\n        type: "float",\n        key: "lightlifetime",\n        label: "Light Lifetime",\n        initial: 1000,\n      },\n      {\n        type: "section",\n        label: "Explosion",\n      },\n      {\n        type: "switch",\n        key: "nftarmor",\n        label: "NFT Armor",\n        options: [\n          { label: "true", value: true },\n          { label: "false", value: false },\n        ],\n        initial: true,\n      },\n      {\n        type: "text",\n        key: "nftarmorcontract",\n        label: "NFT Armor Contract",\n        initial: "0xf53b18570db14c1e7dbc7dc74538c48d042f1332",\n      },\n      { type: "float", key: "blastradius", label: "Blast Radius", initial: 3 },\n      { type: "float", key: "upwardforce", label: "Upward Force", initial: 20 },\n      {\n        type: "section",\n        label: "GIFs",\n      },\n      {\n        type: "float",\n        key: "giflifetime",\n        label: "Gif Lifetime",\n        initial: 4000,\n      },\n      { type: "float", key: "gifscale", label: "Gif Scale", initial: 4 },\n      {\n        type: "float",\n        key: "gifposition",\n        label: "Gif Y Position",\n        initial: 2,\n      },\n      {\n        type: "section",\n        label: "Files",\n      },\n      { type: "file", key: "gif", label: "Air Gif", accept: ".gif" },\n      { type: "file", key: "floorgif", label: "Floor Gif", accept: ".gif" },\n      { type: "file", key: "model", label: "Model", accept: ".glb" },\n      { type: "file", key: "sound", label: "Sound", accept: ".mp3" },\n      {\n        type: "section",\n        label: "Triggers",\n      },\n      {\n        type: "trigger",\n        name: "Destroy",\n      },\n      {\n        type: "trigger",\n        name: "Reset",\n      },\n    ],\n  };\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const l={},s=i.createContext(l);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);